using Content.Client.UserInterface.Controls;
using Content.Shared.Chemistry.Components;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Timing;

namespace Content.Client.Chemistry.UI.Hotplate;

[GenerateTypedNameReferences]
public sealed partial class HotplateMenu : FancyWindow
{
    private static readonly Color PowerOnColor = Color.FromHex("#00FF00"); // Green
    private static readonly Color HeatingColor = Color.FromHex("#FF6A00"); // Orange
    private static readonly Color CoolingColor = Color.FromHex("#00AAFF"); // Light blue
    private static readonly Color DisabledColor = Color.FromHex("#444444"); // Dark gray

    // Consts for adjustment buttons
    private const float InitialAdjustmentRate = 0.1f;
    private const float MaxAdjustmentRate = 50f;
    private const float AdjustmentAcceleration = 1.5f;

    // Style box for status indicator
    private readonly StyleBoxFlat _powerIndicatorStyle;
    private readonly StyleBoxFlat _heatingIndicatorStyle;
    private readonly StyleBoxFlat _coolingIndicatorStyle;

    private float _currentAdjustmentRate = InitialAdjustmentRate;

    private bool _increasePressed;
    private bool _decreasePressed;
    private float _buttonHeldTime;
    private float _lastSentSetpoint;

    private bool _isUserAdjustingMode;

    // These are set from the component, we just cache it here
    private bool _powered;
    private float _minTemperature;
    private float _maxTemperature;
    private float _currentTemperature;
    private float _setpoint;
    private float _hysteresis;

    public event Action<bool>? OnPowerChanged;
    public event Action<float>? OnSetpointChanged;
    public event Action<HotplateMode>? OnModeChanged;

    public HotplateMenu()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _powerIndicatorStyle = new StyleBoxFlat
        {
            BackgroundColor = DisabledColor,
        };
        PowerIndicator.PanelOverride = _powerIndicatorStyle;

        _heatingIndicatorStyle = new StyleBoxFlat
        {
            BackgroundColor = DisabledColor,
        };
        HeatingIndicator.PanelOverride = _heatingIndicatorStyle;

        _coolingIndicatorStyle = new StyleBoxFlat
        {
            BackgroundColor = DisabledColor,
        };
        CoolingIndicator.PanelOverride = _coolingIndicatorStyle;

        PowerButton.StateChanged += powered =>
        {
            // Avoid the delay since power not predicted, will get corrected by the server anyways
            SetPowered(powered);
            OnPowerChanged?.Invoke(powered);
        };

        IncreaseButton.OnButtonDown += _ =>
        {
            _increasePressed = true;
            _buttonHeldTime = 0;
            _currentAdjustmentRate = InitialAdjustmentRate;
        };

        IncreaseButton.OnButtonUp += _ =>
        {
            _increasePressed = false;
            // If button was only clicked briefly, do a single increment
            if (_buttonHeldTime < 0.2f)
            {
                AdjustSetpoint(InitialAdjustmentRate);
            }

            OnSetpointChanged?.Invoke(_setpoint);
        };

        DecreaseButton.OnButtonDown += _ =>
        {
            _decreasePressed = true;
            _buttonHeldTime = 0;
            _currentAdjustmentRate = InitialAdjustmentRate;
        };

        DecreaseButton.OnButtonUp += _ =>
        {
            _decreasePressed = false;
            // If button was only clicked briefly, do a single decrement
            if (_buttonHeldTime < 0.2f)
            {
                AdjustSetpoint(-InitialAdjustmentRate);
            }

            OnSetpointChanged?.Invoke(_setpoint);
        };

        ModeSlider.OnGrabbed += _ => _isUserAdjustingMode = true;

        ModeSlider.OnValueChanged += value =>
        {
            if (!_isUserAdjustingMode)
                return;

            var discreteValue = (int) Math.Round(value.Value);
            discreteValue = Math.Clamp(discreteValue, 0, 2);
            ModeSlider.Value = discreteValue;
        };

        ModeSlider.OnReleased += slider =>
        {
            _isUserAdjustingMode = false;

            // Force snap to integer position when released
            var discreteValue = (int) Math.Round(slider.Value);
            slider.Value = discreteValue;

            var mode = (HotplateMode) discreteValue;
            OnModeChanged?.Invoke(mode);
        };

        UpdateTemperatureDisplay();
        UpdateSetpointDisplay();
        UpdateStatusIndicators();
    }

    public void SetPowered(bool powered)
    {
        if (_powered == powered)
            return;

        _powered = powered;
        PowerButton.IsOn = powered;
        UpdateStatusIndicators();
    }

    public void SetHysteresis(float hysteresis)
    {
        if (MathHelper.CloseTo(_hysteresis, hysteresis))
            return;

        _hysteresis = hysteresis;
    }

    public void SetTemperatureLimits(float min, float max)
    {
        _minTemperature = min;
        _maxTemperature = max;
    }

    public void SetCurrentTemperature(float temperature)
    {
        if (MathHelper.CloseTo(_currentTemperature, temperature))
            return;

        _currentTemperature = temperature;
        UpdateTemperatureDisplay();
    }

    public void SetSetpoint(float setpoint)
    {
        if (MathHelper.CloseTo(_setpoint, setpoint))
            return;

        _setpoint = setpoint;
        UpdateSetpointDisplay();
    }

    public void SetMode(HotplateMode mode)
    {
        if (_isUserAdjustingMode)
            return;

        if ((int) mode == (int) Math.Round(ModeSlider.Value))
            return;

        ModeSlider.Value = (int) mode;
    }

    public void SetBeakerPresent(bool hasBeaker)
    {
        if (BeakerStatusLabel.Visible != hasBeaker)
            return;

        BeakerStatusLabel.Visible = !hasBeaker;
    }

    private void AdjustSetpoint(float adjustment)
    {
        if (!_powered)
            return;

        _setpoint += adjustment;

        _setpoint = Math.Clamp(_setpoint, _minTemperature, _maxTemperature);

        UpdateSetpointDisplay();
    }

    private void UpdateTemperatureDisplay()
    {
        TemperatureValue.Text = $"{_currentTemperature:0.0}"; // TODO: Fluent
    }

    private void UpdateSetpointDisplay()
    {
        SetpointValue.Text = $"{_setpoint:0.0}"; // TODO: Fluent
    }

    public void UpdateStatusIndicators(HotplateActiveState? state = null)
    {
        // Power indicator
        _powerIndicatorStyle.BackgroundColor = _powered ? PowerOnColor : DisabledColor;

        // Only show heating/cooling if powered on
        if (_powered)
        {
            // Update heating/cooling indicators based on active state
            switch (state)
            {
                case HotplateActiveState.Cooling:
                    _coolingIndicatorStyle.BackgroundColor = CoolingColor;
                    _heatingIndicatorStyle.BackgroundColor = DisabledColor;
                    break;
                case HotplateActiveState.Heating:
                    _coolingIndicatorStyle.BackgroundColor = DisabledColor;
                    _heatingIndicatorStyle.BackgroundColor = HeatingColor;
                    break;
                case HotplateActiveState.Idle:
                    _coolingIndicatorStyle.BackgroundColor = DisabledColor;
                    _heatingIndicatorStyle.BackgroundColor = DisabledColor;
                    break;
                case null:
                    _coolingIndicatorStyle.BackgroundColor = DisabledColor;
                    _heatingIndicatorStyle.BackgroundColor = DisabledColor;
                    break;
            }
        }
        else
        {
            // When powered off, all indicators should be off
            _coolingIndicatorStyle.BackgroundColor = DisabledColor;
            _heatingIndicatorStyle.BackgroundColor = DisabledColor;
        }
    }


    protected override void FrameUpdate(FrameEventArgs args)
    {
        base.FrameUpdate(args);

        // Handle temperature adjustment when buttons are held down
        if (!_powered)
            return;

        if (_increasePressed || _decreasePressed)
        {
            _buttonHeldTime += args.DeltaSeconds;

            // Accelerate adjustment rate the longer the button is held
            if (!(_buttonHeldTime > 0.5f))
                return;

            _currentAdjustmentRate = Math.Min(
                MaxAdjustmentRate,
                InitialAdjustmentRate + (_buttonHeldTime - 0.5f) * AdjustmentAcceleration
            );

            var adjustment = _currentAdjustmentRate * args.DeltaSeconds;
            if (_decreasePressed)
                adjustment = -adjustment;

            AdjustSetpoint(adjustment);

            // Send setpoint updates based on hysteresis
            var delta = Math.Abs(_setpoint - _lastSentSetpoint);
            if (delta >= _hysteresis)
            {
                _lastSentSetpoint = _setpoint;
                OnSetpointChanged?.Invoke(_setpoint);
            }
        }
    }
}
